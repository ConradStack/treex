<?xml version="1.0" encoding="utf-8"?>

<pml_schema xmlns="http://ufal.mff.cuni.cz/pdt/pml/schema/"  version="1.1">
  <revision>1.0.0</revision>
  <description>Subschema for a-layer trees</description>

  <import type="p-function.type" schema="treex_subschema_p_layer.xml"/>

  <!-- generic (language-independent) m-layer representation -->

  <type name="m-node.type">
    <structure name="m-node" role="#NODE">
      <member name="id" as_attribute="1" role="#ID" required="0"><cdata format="ID"/></member>
      <member name="src.rf"><cdata format="PMLREF"/></member>
      <member name="w.rf">
         <!-- zakomentovana role="#KNIT" type="w-node.type"-->
         <list ordered="1"><cdata format="PMLREF"/></list> 
      </member>
      <member name="form_change" type="m-form_change.type">
<!--        <choice>
          <value>ctcd</value>
          <value>spell</value>
          <value>insert</value>
          <value>num_normalization</value>
        </choice> -->
      </member>
      <!--
        Offset is position (starting with 0) of the first character of the form in the source sentence.
        It is needed for late sentence segmentation.
        (20.6.2008 zeman)
      -->
      <member name="offset"><cdata format="any"/></member>
      <member name="form"><cdata format="any"/></member>
      <!--
        Form transliterated to another script. Typically the target script is Latin
        and transliteration means romanization.
      -->
      <member name="translit"><cdata format="any"/></member>
      <member name="lemma"><cdata format="any"/></member>
      <member name="tag"><cdata format="any"/></member>
      <member name="gloss"><cdata format="any"/></member>
      <!--
        2.1.2008 ptacek: need this for get_sentence_string()
      -->
      <member name="w">
        <list ordered="1">
          <structure name="w-node">
            <member name="token">
              <cdata format="any"/>
            </member>
            <member name="no_space_after" type="bool.type"/>
          </structure>
        </list>
      </member>
      <!--
        8.2.2010 ptacek: no_space_after temporarily allowed 
        so data generated by pdt-to-tmt before continue to be valid
        (please rerun your conversions)
      -->
      <member name="no_space_after" type="bool.type"/>
      
      <member name="align">
        <structure>
           <member name="giza_links">
             <list ordered="0" type="align-links.type"/>
           </member>
           <member name="links">
             <list ordered="0" type="align-links.type"/>
           </member>
           <member name="manual_links">
             <list ordered="0" type="align-links.type"/>
           </member>
        </structure>
      </member>
    </structure>
  </type>


 <!--  a-layer representation (merged with m-layer) -->


  <type name="a-root.type">
    <structure role="#NODE" name="a-root">
      <member name="id" role="#ID" as_attribute="1"  required="1"><cdata format="ID"/></member>
      <member name="language" as_attribute="1" ><cdata format="any"/></member>
      <member name="direction" as_attribute="1"><cdata format="any"/></member>

      <member name="ptree.rf">
         <cdata format="PMLREF"/>
      </member>

      <member name="s.rf"><cdata format="PMLREF"/></member>
      <member name="afun"><constant>AuxS</constant></member>
      <member name="ord" role="#ORDER" required="1"><cdata format="nonNegativeInteger"/></member>
      <member name="children" role="#CHILDNODES">
        <list type="a-node.type" ordered="1"/>
      </member>
      <!-- Should the sentence be parsed once again?
           This is useful when tags has been fixed (with the knowledge of the parse). Popel 23.5.2009 -->
      <member name="reparse" type="bool.type"/>
    </structure>
  </type>


  <type name="a-node.type">
    <structure role="#NODE" name="a-node">
      <member name="id" role="#ID" as_attribute="1" required="1"><cdata format="ID"/></member>

      <!-- former m-layer attributes (reduced) -->
      <member name="form"><cdata format="any"/></member>
      <member name="translit"><cdata format="any"/></member>
      <member name="lemma"><cdata format="any"/></member>
      <member name="tag"><cdata format="any"/></member>
      <member name="no_space_after" type="bool.type"/>
      <member name="children" role="#CHILDNODES">
        <list type="a-node.type" ordered="1"/>
      </member>

      <!-- former a-layer attributes -->
      <member name="ord" role="#ORDER" required="1"><cdata format="nonNegativeInteger"/></member>
      <member name="afun" type="afun.type" />
      <member name="is_member" type="bool.type"/>
      <member type="bool.type" name="is_parenthesis_root"/> <!-- ??? -->
      <member name="conll_deprel"><cdata format="any"/></member>

      <!-- attributes for conversion to t-tree -->
      <member type="bool.type" name="is_aux_to_child"/>
      <member type="bool.type" name="is_aux_to_parent"/>
      <member type="bool.type" name="parent_is_aux"/>
      <member type="bool.type" name="edge_to_collapse"/>
      <member type="bool.type" name="is_auxiliary"/>

      <!-- clause segmentation -->
      <member name="clause_number"><cdata format="any"/></member>
      <member type="bool.type" name="is_clause_head"/> <!-- We mean finite clause head, but that's the same as with is_clause_head on t-layer!!! -->


      <!-- links to p-layer -->
      <member name="functions"> <!-- redundant, the same info could be provided by API - ??? -->
        <list type="p-function.type" ordered="1"/>
      </member>
      <member name="p" type="a-p.type"/>
 

      <member name="morphcat" type="czech_morphcat.type"/>
         
      <member name="is_indeclinable" type="bool.type"/>
      <member name="delayed_reorder">
        	<structure>
        		<member name="non_projective_shift_to_leftmost_of"><cdata format="any"/></member>
        	</structure>
      </member>

      <!-- surface coreference -->
      <member  name="coref" type="a_coreference.type"/>


    </structure>
  </type>


  <type name="a_coreference.type"> <!-- analyticka koreference pro Jirku Mirovskeho -->
    <structure>
       <member name="markable" type="bool.type"/> <!-- a token to be considered as anaphor/antecedent -->
       <member name="introduction" type="bool.type"/> <!-- first introduction of the entity to the discourse -->
       <member name="anaphor_type"> <cdata format="any"/> </member> <!-- the type of the anaphor - pronoun, proper_noun, demonstrative_noun_phrase, common_noun -->
       <member name="target-node.rf"> <cdata format="PMLREF"/> </member>
       <member name="type"> <cdata format="any"/> </member>
       <member name="src"> <cdata format="any"/> </member>
    </structure>
  </type>


  <type name="a-p.type">
    <structure>
       <member name="terminal.rf">
         <cdata format="PMLREF"/>
       </member>
       <member name="nonterminals.rf">
          <list ordered="0">
             <cdata format="PMLREF"/>
          </list>
       </member>
    </structure>
  </type>

  <type name="afun.type">
    <choice>
      <value>Pred</value>
      <value>Pnom</value>
      <value>AuxV</value>
      <value>Sb</value>
      <value>Obj</value>
      <value>Atr</value>
      <value>Adv</value>
      <value>AtrAdv</value>
      <value>AdvAtr</value>
      <value>Coord</value>
      <value>AtrObj</value>
      <value>ObjAtr</value>
      <value>AtrAtr</value>
      <value>AuxT</value>
      <value>AuxR</value>
      <value>AuxP</value>
      <value>Apos</value>
      <value>ExD</value>
      <value>AuxC</value>
      <value>Atv</value>
      <value>AtvV</value>
      <value>AuxO</value>
      <value>AuxZ</value>
      <value>AuxY</value>
      <value>AuxG</value>
      <value>AuxK</value>
      <value>AuxX</value>
      <!-- afun for articles/determiners used in en_generate. ptacek 2008 -->
      <value>Det</value>
      <!-- afun for English articles "a", "an", "the" (used in SEnglishM_to_SEnglishA).
           Other determiners (this,each,any,some,every,no... PennTag=DT) have usually afun Atr. Popel 9.5.2009 -->
      <value>AuxA</value>
      <!-- afun for english negation "not". On PDT-like t-layer it should be #Neg node, so it's not auxiliary, I think. Popel 9.5.2009 -->
      <value>Neg</value>
      <!-- values added because of Prague Arabic Dependency Treebank -->
      <value>AuxM</value>
      <value>AuxE</value>
      <value>Ante</value>
      <!-- afun for unrecognized value -->
      <value>NR</value>
    </choice>
  </type>

  <type name="czech_morphcat.type">
    <structure>
        <member name="pos"><cdata format="any"/></member>
        <member name="subpos"><cdata format="any"/></member>
        <member name="synpos"><cdata format="any"/></member>
        <member name="gender"><cdata format="any"/></member>
        <member name="number"><cdata format="any"/></member>
        <member name="case"><cdata format="any"/></member>
        <member name="possgender"><cdata format="any"/></member>
        <member name="possnumber"><cdata format="any"/></member>
        <member name="person"><cdata format="any"/></member>
        <member name="tense"><cdata format="any"/></member>
        <member name="grade"><cdata format="any"/></member>
        <member name="negation"><cdata format="any"/></member>
        <member name="voice"><cdata format="any"/></member>
        <member name="reserve1"><cdata format="any"/></member>
        <member name="reserve2"><cdata format="any"/></member>
        <!-- ptacek 5.8.2008 for en/cz_generate -->
        <member name="compound_person"><cdata format="any"/></member>
        <member name="compound_number"><cdata format="any"/></member>
        <member name="compound_gender"><cdata format="any"/></member>
        <member name="ordering_type"><cdata format="any"/></member>
        <!-- zabokrtsky because of Arabic -->
        <member name="definiteness"><cdata format="any"/></member>
        <member name="mood"><cdata format="any"/></member>
    </structure>
  </type>

  <type name="align-links.type">
    <structure>
       <member name="counterpart.rf">
          <cdata format="PMLREF"/>
       </member>
       <member name="type">
          <cdata format="any"/>
       </member>
    </structure>
 </type>


  <type name="m-form_change.type">
    <choice>
      <value>ctcd</value>
      <value>spell</value>
      <value>insert</value>
      <value>num_normalization</value>
    </choice>
  </type>



<!-- radeji do common -->
  <type name="bool.type">
    <choice>
      <value>0</value>
      <value>1</value>
    </choice>
  </type>


</pml_schema>
